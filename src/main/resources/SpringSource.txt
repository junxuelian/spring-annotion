Spring容器的refresh()[创建刷新]
1、prepareRefresh()刷新的预处理
    1)、initPropertySources()初始化一些属性设置，子类自定义个性化的属性设置方法
    2)、getEnvironment().validateRequiredProperties();校验属性的合法等
    3)、this.earlyApplicationEvents = new LinkedHashSet<>();保存容器中早期的一些事件
2、obtainFreshBeanFactory();获取BeanFactory
    1)、refreshBeanFactory();刷新[创建]BeanFactory
        创建一个this.beanFactory = new DefaultListableBeanFactory()；
        设置id；
    2)、getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象
    3)、将创建的BeanFactory[DefaultListableBeanFactory]返回
3、PrepareBeanFactory(beanFactory);beanFactory的预准备工作（BeanFactory进行一些设置）
    1)、设置BeanFactory的类加载器、支持表达式解析器。。。
    2)、添加部分BeanPostProcessor[ApplicationContextAwareProcessor]
    3)、设置忽略的自动装配的接口EnvironmentAware。。。。。
    4)、注册可以解析的自动装配，我们能直接在任何组件中自动注入，
    BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext
    5)、添加BeanPostProcessor[ApplicationListenerDetector]
    6)、添加编译时的AspectJ
    7)、给BeanFactory中注册中的一些能用的组件；
        environment[ConfigurableEnvironment]
        systemProperties[Map<String, Object> getSystemProperties()]
        systemEnvironment[Map<String, Object> getSystemEnvironment()]
4、postProcessBeanFactory(beanFactory);BeanFactory准备工作完成后进行的后置处理工作；
    1)、子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置
=============================以上是BeanFactory的创建以及预准备工作=========================================
5、invokeBeanFactoryPostProcessors(beanFactory);执行BeanFactoryPostProcessor；
    BeanFactoryPostProcessor;BeanFactory的后置处理器，在BeanFactory标准初始化之后执行的
    两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor
    1)、执行BeanDefinitionRegistryPostProcessor的方法；
        1)、获取所有的BeanDefinitionRegistryPostProcessor；
        2)、先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor
            postProcessBeanDefinitionRegistry(registry)
        3)、再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor
            postProcessBeanDefinitionRegistry(registry)
        4)、最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessor；
            postProcessBeanDefinitionRegistry(registry)
    2)、再执行BeanFactoryPostProcessor的方法
        1)、获取所有的BeanDefinitionRegistryPostProcessor；
                2)、先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor
                    postProcessBeanDefinitionRegistry(registry)
                3)、再执行实现了Ordered顺序接口的BeanFactoryPostProcessor
                    postProcessBeanDefinitionRegistry(registry)
                4)、最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor
                    postProcessBeanDefinitionRegistry(registry)

6、registerBeanPostProcessors(beanFactory);注册BeanPostProcessor(Bean的后置处理器)[intercept bean creation]
    不同类型的BeanPostProcessor，在Bean创建前后的执行时机不一样
    BeanPostProcessor、DestructionAwareBeanPostProcessor、InstantiationAwareBeanPostProcessor
    SmartInstantiationAwareBeanPostProcessor、MergedBeanDefinitionPostProcessor
    1)、获取所有的BeanPostProcessor，后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级
    2)、先注册PriorityOrdered优先级接口的BeanPostProcessor;
        把每一个BeanPostProcessor,添加到BeanFactory中
        beanFactory.addBeanPostProcessor(PostProcessor);
    3)、再注册Ordered顺序接口的BeanPostProcessor;
    4)、最后注册没有实现任何接口的BeanPostProcessor;
    5)、最终注册MergedBeanDefinitionPostProcessor
    6)、注册一个ApplicationListenerDetector，来在Bean创建完成后检查是否是ApplicationListener，如果是
        this.applicationContext.addApplicationListener((ApplicationListener<?>) bean);
7、initMessageSource();初始化MessageSource组件（做国际化功能，消息绑定，消息解析）
    1）、获取BeanFactory
    2）、看容器中是否有id为messageSource的组件，如果有赋值给messageSource，
        如果没有自己创建一个DelegatingMessageSource.
        MessageSource：取出国际化配置文件中的某个key的值；按照区域信息获取

    3）、把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource
        beanFactory.registerSingleton("messageSource", this.messageSource);
        MessageSource.String getMessage(MessageSourceResolvable resolvable, Locale locale)
8、initApplicationEventMulticaster(),初始化事件派发器
    1）、获取BeanFactory
    2）、从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster
    3)、如果上一步没有配置，创建一个SimpleApplicationEventMulticaster
    4)、将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件直接自动注入
9、onRefresh(),留给子容器（子类）
    1）、子类重写这个方法，在容器中将所有项目里面的ApplicationEventMulticaster注册进来。
10、registerListeners();给容器中将所有项目里面的ApplicationListener注册进来
    1）、从容器中拿到所有的ApplicationListener
    2）、将每个监听器添加到事件派发器中；
        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
    3）、派发之前步骤产生的事件；
11、finishBeanFactoryInitialization(beanFactory);初始化所有剩下的单实例bean
    1)、beanFactory.preInstantiateSingletons(),
        1）、获取容器中的所有Bean，依次进行初始化和创建对象
        2）、获取Bean的定义信息，RootBeanDefinition
        3）、Bean不是抽象的，是单实例的，是不是懒加载的
            1）、判断是否是FactoryBean,是否是实现FactoryBean接口的Bean
            2）、不是工厂Bean。利用getBean(beanName),创建对象
                1)、getBean(beanName), ioc.getBean();
                2)、doGetBean(name, null, null, false);
                3）、先获取缓存中保存的单实例Bean。如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bea都会被缓存起来）
                4）、缓存中获取不到，开启创建流程
                5）、获取Bean的定义信息
                6）、获取当前Bean依赖的其他Bean，如果有按照getBean()把依赖的Bean先创建出来
                7）、 启动单实例Bea的创建流程
                    1)、createBean(beanName, mbd, args);
                    2)、Object bean = resolveBeforeInstantiation(beanName, mbdToUse);让Bean
                    InstantiationAwareBeanPostProcessor:提前执行
                先触发：postProcessBeforeInstantiation()；
                如果有返回值：触发：postProcessAfterInstantiation()；
                    3)、如果前面的postProcessAfterInstantiation（）没有返回代理对象，调用4）
                    4）、Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean
                        1)、创建Bean实例：createBeanInstance(beanName, mbd, args);
                            利用工厂方法或者对象构造器创建Bean实例。
                        2）、applyMergedBeanDefinitionPostProcessor
                            bdp.postProcessMergeBeanDefinitionProcessor(mbd, beanType, beanName)
                        3）、对Bean进行赋值populateBean（beanName,mbd, instanceWrapper);
                            赋值之前：
                            1)、拿到InstantiationAwareBeanPostProcessor后置处理器
                                postProcessAfterInstantiation()
                            2)、拿到InstantiationAwareBeanPostProcessor后置处理器
                                postProcessPropertyValues()
                            ==============赋值之前==============
                            3)、应用Bean属性的值，为属性利用setter方法等赋值，
                                applyPropertyValues(beanName, mbd, bw, pvs)
                            4)、[Bean初始化]initializeBean(beanName, exposedObject, mbd);
                                1)、[执行Aware接口方法]invokeAwareMethods(beanName, bean)；执行xxxAware接口的方法
                                    BeanNameAware\BeanClassLoaderAware\BeanFactoryAware
                                2)、[执行后置处理器初始化之前]applyBeanPostProcessorBeforeInitialization(wrappedBean, beanName, )
                                    BeanPostProcessor.postProcessBeforeInitialization()
                                3)、[执行初始化方法]invokeInitMethods(beanName, wrappedBean, mbd);
                                    1)、是否是InitializingBean接口的实现，执行接口规定的初始化；
                                    2）、是否自定义初始化
                                4）、[执行后置处理器]applyBeanPostProcessorsAfterInitialization
                                    BeanPostProcessor.postProcessAfterInitialization()
                                5)、注册Bean的销毁方法；
                            5）、将注册的Bean添加到缓存中singletonObjects；
                            ioc容器就是这些Map；很多Map里面保存了单实例Bean，环境信息，等等。
                     所有Bean都利用getBean创建完成以后，检查所有的Bean是否是SmartInitializingSingleton接口，如果是；
                     就执行afterSingletonsInstantiated（）；
12、finishRefresh();完成BeanFactory的初始化工作，IOC容器就创建完成；
        1）、initLifecycleProcessor();初始化和生命周期有关的后置处理器；LifecycleProcessor；
        加入到容器中
            写一个LifecycleProcessor的实现类，可以再BeanFactory
                void onRefresh()
                void onClose()
        2)、getLifecycleProcessor().onRefresh();
        拿到前面定义的生命周期处理器（BeanFactory）;回调onRefresh（）；
        3）、publishEvent(new ContextRefreshedEvent(this)),发布容器刷新完成事件
        4）、liveBeansView.registerApplicationContext(this);

================总结==============
1）、Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息；
    1）、xml注册bean；<bean>
    2）、注册Bean，@Service，@Component,@Bean、XXX
2）、Spring容器会合适时机创建这些Bean
    1）、用到这个bean的时候，利用getBean创建bean；创建好以后保存在容器中；
    2）、统一创建剩下所有Bean的时候，finishBeanFactoryInitialization();
3)、后置处理器：
        每一个bean创建完成，都会使用各种后置处理器进行处理，来增强Bean的功能；
        AutowiredAnnotationBeanPostProcessor:处理自动注入
        AnnotationAwareAspectJAutoProxyCreator,来做AOP功能
        XXX...
        增强的注解功能：
        AsyAnnotionBeanPostProcessor;
        .......

4)、事件驱动模型：
    ApplicationListener:事件监听
    事件派发：ApplicationEventMulticaster,事件派发。






























